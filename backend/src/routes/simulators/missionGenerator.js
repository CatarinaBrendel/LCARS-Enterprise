// src/sim/generate.js
import { query } from '../../../database/db.js';

const SECTORS = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Tau'];
const AUTHORITIES = ['Starfleet Command', 'Science Council', 'Colony Admin', 'Diplomatic Corps'];
const OBJ_TITLES = [
  'Scan anomaly', 'Deliver supplies', 'Rescue survivors',
  'Negotiate truce', 'Repair subspace relay', 'Map nebula corridor'
];

const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
const sample = (arr, n) => arr.slice().sort(() => Math.random() - 0.5).slice(0, n);

// tiny parser: "15s" | "10m" | "2h" | "120000" (ms)
function parseHumanMs(v, fallback) {
  if (v == null) return fallback;
  const s = String(v).trim().toLowerCase();
  if (/^\d+$/.test(s)) return Number(s);               // plain ms
  const m = s.match(/^(\d+(?:\.\d+)?)(ms|s|m|h)$/);
  if (!m) return fallback;
  const num = Number(m[1]);
  const unit = m[2];
  const mult = unit === 'ms' ? 1 : unit === 's' ? 1_000 : unit === 'm' ? 60_000 : 3_600_000;
  return Math.round(num * mult);
}

function formatMs(ms) {
  const h = Math.floor(ms / 3_600_000);
  const m = Math.floor((ms % 3_600_000) / 60_000);
  const s = Math.floor((ms % 60_000) / 1_000);
  if (h) return `${h}h ${m}m`;
  if (m) return `${m}m ${s}s`;
  return `${s}s`;
}

/**
 * Create one mission with objectives (and optionally teams), inside a transaction.
 * If emitters.emitMissionCreated is provided, it will be called AFTER COMMIT.
 *
 * @param {object} opts
 * @param {number} [opts.objectivesMin=2]
 * @param {number} [opts.objectivesMax=4]
 * @param {string} [opts.sector]
 * @param {string} [opts.authority]
 * @param {number} [opts.stardate]
 * @param {boolean} [opts.withTeams=true]
 * @param {object} emitters
 * @param {(id:number)=>void} [emitters.emitMissionCreated]
 * @returns {Promise<{id:number, code:string, sector:string, authority:string, status:string, progress_pct:number, stardate:number, objectives:any[], teams:any[]}>}
 */
export async function createRandomMission(
  {
    objectivesMin = 2,
    objectivesMax = 4,
    sector = pick(SECTORS),
    authority = pick(AUTHORITIES),
    // “stardate-ish”: totally arbitrary, just stable-ish
    stardate = Math.round(Date.now() / 86_400_000) + 41000,
    withTeams = true,
  } = {},
  { emitMissionCreated } = {}
) {
  await query('BEGIN');
  let mission;
  let insertedObj = [];
  let teams = [];

  try {
    // 1) mission
    const code = `MSN-${Math.random().toString(36).slice(2, 8).toUpperCase()}`;
    const { rows: mRows } = await query(
      `INSERT INTO mission (code, sector, authority, status, progress_pct, stardate, created_at, updated_at)
       VALUES ($1,$2,$3,'planned',0,$4,NOW(),NOW())
       RETURNING id, code, sector, authority, status, progress_pct, stardate`,
      [code, sector, authority, stardate]
    );
    mission = mRows[0];

    // 2) objectives
    const howMany = rand(objectivesMin, objectivesMax);
    const chosen = sample(OBJ_TITLES, howMany);
    for (let i = 0; i < chosen.length; i++) {
      const title = chosen[i];
      const details = 'Autogenerated objective';
      const priority = howMany - i;
      const { rows } = await query(
        `INSERT INTO mission_objective (mission_id, title, details, state, priority, created_at, updated_at)
         VALUES ($1,$2,$3,'not_started',$4,NOW(),NOW())
         RETURNING id, title, details, state, priority`,
        [mission.id, title, details, priority]
      );
      insertedObj.push(rows[0]);
    }

    // 3) optional teams
    if (withTeams) {
      teams = await safeAssignTeams(mission.id);
    }

    await query('COMMIT');
  } catch (e) {
    await query('ROLLBACK');
    throw e;
  }

  // 4) after commit, notify UI (fires mission:status, mission:progress, mission:event created)
  try { emitMissionCreated?.(mission.id); } catch {}

  return { ...mission, objectives: insertedObj, teams };
}

/**
 * Create 1–3 teams and assign 3–6 random crew to each, using your schema:
 *   - mission_team (mission_id, name, lead_crew_id, notes)
 *   - mission_team_assignment (team_id, crew_id, role, joined_at, left_at)
 *
 * Falls back gracefully if tables don’t exist.
 */
async function safeAssignTeams(missionId) {
  try {
    // pick some random crew if table exists
    const { rows: crew } = await query(`SELECT id, name FROM crew ORDER BY random() LIMIT 24`);
    const nTeams = rand(1, 3);
    const out = [];

    for (let t = 0; t < nTeams; t++) {
      const name = ['Alpha Team', 'Bravo Team', 'Gamma Team', 'Delta Team', 'Omega Team'][t % 5];

      const { rows: tRows } = await query(
        `INSERT INTO mission_team (mission_id, name, lead_crew_id, notes)
         VALUES ($1, $2, NULL, 'Auto') RETURNING id, mission_id, name`,
        [missionId, name]
      );
      const team = tRows[0];

      const members = sample(crew, rand(3, 6));
      for (const m of members) {
        await query(
          `INSERT INTO mission_team_assignment (team_id, crew_id, role, joined_at)
           VALUES ($1, $2, 'member', NOW())`,
          [team.id, m.id]
        );
      }

      out.push({ ...team, members });
    }

    return out;
  } catch (e) {
    // undefined_table or any schema miss: just return mock so UI renders
    return [
      { id: -1, mission_id: missionId, name: 'Alpha Team', members: [
        { id: 10001, name: 'Crew A' },
        { id: 10002, name: 'Crew B' }
      ] }
    ];
  }
}

/**
 * Optional background generator you can start behind a flag.
 * Returns a stop() function.
 */
export function startMissionGenerator({
  emitMissionCreated,
  withTeams = true,
  minDelayMs = parseHumanMs(process.env.MISSION_GEN_MIN || '15s', 15_000),
  maxDelayMs = parseHumanMs(process.env.MISSION_GEN_MAX || '24h', 86_400_000),
  logger = console,
} = {}) {
  // normalize bounds
  let min = Math.max(1_000, Math.floor(minDelayMs));
  let max = Math.max(min + 1_000, Math.floor(maxDelayMs));
  if (max < min) [min, max] = [max, min];

  let timer = null;
  let stopped = false;

  const nextDelay = () => {
    const span = max - min;
    return min + Math.floor(Math.random() * (span + 1));
  };

  const scheduleNext = () => {
    if (stopped) return;
    const d = nextDelay();
    logger.log(`[missionGen] next creation in ${formatMs(d)} (range ${formatMs(min)}–${formatMs(max)})`);
    timer = setTimeout(tick, d);
  };

  const tick = async () => {
    try {
      logger.log('[missionGen] creating mission…');
      const m = await createRandomMission({ withTeams }, { emitMissionCreated });
      logger.log('[missionGen] created', m.id, m.code);
    } catch (err) {
      logger.error('[missionGen] createRandomMission error:', err?.stack || err);
    } finally {
      scheduleNext(); // always schedule after completion (no overlap)
    }
  };

  // kick once immediately, then randomize subsequent runs
  logger.log(`[missionGen] random interval active (${formatMs(min)}–${formatMs(max)})`);
  tick().catch(() => scheduleNext());

  // provide stopper
  return () => { stopped = true; if (timer) clearTimeout(timer); };
}
